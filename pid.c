#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           rightDrive,    tmotorVex393_MC29, PIDControl, reversed, driveRight, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftDrive,     tmotorVex393_MC29, PIDControl, driveLeft, encoderPort, dgtl3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define PID_INTEGRAL_MAX 60
#define ERROR_LIMIT 30
#define MAX_SPEED 80

//debug shit
float rightEncode = 0;
int rightMotor = 0;
int driveSpeed;

		float error = 0;
		float prevError = 0;
		float integral = 0;
		float derivative = 0;

float leftEncode = 0;
float kPRight = 1.00;
float kIRight = 0.05;
float kDRight = 0.02;
float distance = -720;
task pidRight()
{
		//wait1Msec(10);
		SensorValue[rightEncoder] = 0;
		float curEncoderValue = SensorValue[rightEncoder];

		while(1) {
			curEncoderValue = SensorValue[rightEncoder];
			error = distance - curEncoderValue;
			if(abs(error)<PID_INTEGRAL_MAX){
				integral += error;
			}
			else {
				integral = 0;
			}
			derivative = error-prevError;
			prevError = error;
			int driveValue = kPRight*error + kIRight*integral + kDRight*derivative;
			driveSpeed = driveValue;
			if(driveValue>MAX_SPEED) {
				driveValue = MAX_SPEED;
			}
			else if(driveValue<-1 * MAX_SPEED) {
				driveValue= -1 * MAX_SPEED;
			}
			motor[rightDrive] = driveValue;
			motor[leftDrive] = driveValue;
			if(abs(error)<ERROR_LIMIT){
				motor[rightDrive] = 0;
				motor[leftDrive] = 0;
				break;
			}
			wait1Msec(25);
		}
}
task pidLeft()
{
		//motor[leftDrive] = 127;
		SensorValue[leftEncoder] = 0;
		float curEncoderValue = SensorValue[leftEncoder];
		float error = 0;
		float prevError = 0;
		float integral = 0;
		float derivative = 0;
		while(1) {
			curEncoderValue = SensorValue[leftEncoder];
			error = SensorValue[rightEncoder] - curEncoderValue;
			if(abs(error)<PID_INTEGRAL_MAX){
				integral += error;
			}
			else {
				integral = 0;
			}
			derivative = error-prevError;
			prevError = error;
			int driveValue = kPRight*error + kIRight*integral + kDRight*derivative;
			if(driveValue>127) {
				driveValue=127;
			}
			else if(driveValue<-128) {
				driveValue=-128;
			}
			motor[leftDrive] = driveValue;
			if(motor[rightDrive]==0){
				//motor[rightDrive] = 0;
				motor[leftDrive] = 0;
				break;
			}
			wait1Msec(25);
		}
}
void driveForward(float rotorTicks) {
	distance = rotorTicks;
	startTask(pidRight);
	startTask(pidLeft);
}
task main()
{
	wait1Msec(2000);
	//driveForward(720);
	startTask(pidRight);
	while(1) {
			rightEncode = SensorValue[rightEncoder];
			rightMotor = motor[rightDrive];
	}
	/*SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	while(1) {
		motor[rightDrive] = 127;
		motor[leftDrive] = 127;
		rightEncode = SensorValue[rightEncoder];
		leftEncode = SensorValue[leftEncoder];
	}
	moveMotorTarget(rightDrive, 720, 127, true);
	moveMotorTarget(leftDrive, -720, 127, true);
	wait1Msec(5000);
	while(!getMotorTargetCompleted(rightDrive) || !getMotorTargetCompleted(leftDrive)) {
		rightEncode = SensorValue[rightEncoder];
		leftEncode = SensorValue[leftEncoder];
	}*/
}
